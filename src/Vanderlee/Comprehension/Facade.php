<?php

namespace vanderlee\comprehension;

use vanderlee\comprehension\parser\AbstractParser;
use vanderlee\comprehension\core\Context;

/**
 * Description of Facade
 *
 * @author Martijn
 */
class Facade extends AbstractParser {

	/**
	 * The entire parser tree root node
	 * @var AbstractParser
	 */
	private $parser = null;
	
	/**
	 * The most recent parser added to the tree by the user (excluding parsers
	 * generated by the Facade itself).
	 * @var AbstractParser
	 */
	private $current = null;

	public static function __callStatic(string $name, array $arguments)
	{
		$method = "composite_$name";

		if (!method_exists(Facade::class, $method)) {
			throw new Exception("Method `{$method}` not available");
		}

		$facade = new Facade();

		call_user_func_array([$facade, "composite_$name"], $arguments);

		return $facade;
	}

	public function __call(string $name, array $arguments)
	{
		$method = "composite_$name";

		if (!method_exists($this, $method)) {
			throw new Exception("Method `{$method}` not available");
		}

		call_user_func_array([$this, $method], $arguments);

		return $this;
	}
	
	protected function parse($in, $offset, Context $context)
	{
		if ($this->parser === null) {
			return $this->createMismatch(self::INVALID_ARGUMENTS);
		}

		$match = $this->parser->parse($in, $offset, $context);
		
		if ($match->match) {
			return $this->createMatch($in, $offset, $match->length, $match);
		} else {
			return $this->createMismatch($in, $offset, $match->length, $match);
		}
	}

	public function assignTo(&$variable)
	{
		if ($this->current) {
			$this->current->assignto($variable);
		} else {
			parent::assignTo($variable);
		}

		return $this;
	}

	public function resultAs($name)
	{
		if ($this->current) {
			$this->current->resultAs($name);
		} else {
			parent::resultAs($name);
		}
		return $this;
	}

	private function composite($parser)
	{
		if (empty($this->parser)) {
			$this->parser = $parser;
		} elseif ($this->parser instanceof parser\Sequence) {
			$this->parser->add($parser);
		} else {
			$this->parser = new parser\Sequence($parser);
		}

		$this->current = $parser;

		return $this;
	}

	private function composite_text($text)
	{
		return $this->composite(new parser\Text($text));
	}

}
